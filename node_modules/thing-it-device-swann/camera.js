module.exports = {
    metadata: {
        family: "camera",
        plugin: "camera",
        label: "Swann Â© Camera",
        tangible: true,
        state: [{id: "video", label: "Video", type: {id: "video"}}],
        actorTypes: [],
        sensorTypes: [],
        services: [],
        configuration: [{
            id: "url",
            label: "URL",
            type: {id: "string"}
        }, {
            id: "inputFormat",
            label: "Input Format",
            type: {id: "string"}
        },
            {id: "videoWidth", label: "Video Width", type: {id: "integer"}, default: "320"}, {
                id: "videoHeight",
                label: "Video Height",
                type: {id: "integer"},
                default: "180"
            }]
    },
    create: function () {
        return new Camera();
    }
};

var q = require('q');
var child_process = require('child_process');
var ffmpeg;

/**
 *
 */
function Camera() {
    /**
     *
     */
    Camera.prototype.start = function () {
        var deferred = q.defer();

        this.state = {};

        if (this.isSimulated()) {
            deferred.resolve();
        } else {
            deferred.resolve();
        }

        return deferred.promise;
    };

    /**
     *
     */
    Camera.prototype.setState = function (state) {
        this.state = state;
    };

    /**
     *
     */
    Camera.prototype.getState = function () {
        return this.state;
    };

    /**
     *
     */
    Camera.prototype.streamWebCam = function (req, res) {
        //if (!ffmpeg) {
        //    ffmpeg = require("fluent-ffmpeg");
        //}

        this.logDebug("Start WebCam Streaming");

        // Should mimick ffmpeg -f qtkit -video_device_index 0 -i "" out.mpg

        //ffmpeg().input("0"/*this.configuration.inputDevice*/).inputFormat("qtkit"/*this.configuration.inputFormat*/)
        //    .duration(5000 /*this.configuration.latency*/)/*.size(this.videoSize)*/
        //    /*.pipe(res)*/
        //    .output("./out.mpg")
        //    .on('end', function () {
        //        this.streamWebCam();
        //    }.bind(this))
        //    .on('error', function (error) {
        //        this.logError(error);
        //    }.bind(this));


        ffmpeg = child_process.spawn("ffmpeg", [
            "-f", "qtkit", "-video_device_index", "0", "-i", "", "-f", "mp4", "-movflags", "frag_keyframe+empty_moov",
            "-reset_timestamps", "1", "out.mpg"
        ], {detached: false});

        ffmpeg.stdout.pipe(res);

        ffmpeg.stdout.on("data", function (data) {
            this.logDebug("Data");
        }.bind(this));

        ffmpeg.stderr.on("data", function (data) {
            this.logError("Error -> " + data);
        }.bind(this));

        ffmpeg.on("exit", function (code) {
            this.logDebug("ffmpeg terminated with code " + code);
        }.bind(this));

        ffmpeg.on("error", function (e) {
            this.logError("ffmpeg system error: " + e);
        }.bind(this));
    };
    /**
     *
     */
    Camera.prototype.video = function (req, res) {
        if (this.isSimulated()) {
            this.logDebug("Piping file");
            this.pipeFile(req, res, __dirname + "/data/spaceship.m4v", "video/mp4");
        }
        else if (true) {
            this.streamWebCam(req, res);
        }
        else if (false) {
            var input = 'udp://225.1.1.1:8208'; // this.configuration.url

            this.logDebug("Input: " + input, ffmpeg);

            res.writeHead(200, {
                //'Transfer-Encoding': 'binary'
                "Connection": "keep-alive"
                , "Content-Type": "video/mp4"
                //, 'Content-Length': chunksize            // ends after all bytes delivered
                , "Accept-Ranges": "bytes"                 // Helps Chrome
            });

            if (!ffmpeg) {
                // TODO use require("fluent-ffmpeg") and code like pushCameraInput on top

                ffmpeg = child_process.spawn("ffmpeg", [
                    "-i", input, "-vcodec", "copy", "-f", "mp4", "-movflags", "frag_keyframe+empty_moov",
                    "-reset_timestamps", "1", "-vsync", "1", "-flags", "global_header", "-bsf:v", "dump_extra", "-y", "-"   // output to stdout
                ], {detached: false});

                ffmpeg.stdout.pipe(res);

                ffmpeg.stdout.on("data", function (data) {
                    this.logDebug("Data");
                });

                ffmpeg.stderr.on("data", function (data) {
                    this.logError("Error -> " + data);
                });

                ffmpeg.on("exit", function (code) {
                    this.logDebug("ffmpeg terminated with code " + code);
                });

                ffmpeg.on("error", function (e) {
                    this.logError("ffmpeg system error: " + e);
                });
            }

            req.on("close", function () {
                closeStream("closed")
            })

            req.on("end", function () {
                closeStream("ended")
            });

            function closeStream(event) {
                //TODO: Stream is only shut when the browser has exited, so switching screens in the client app does not kill the session
                console.log("Live streaming connection to client has " + event)
                if (ffmpeg) {
                    ffmpeg.kill();

                    ffmpeg = null;
                }
            }
        }
    };
}
