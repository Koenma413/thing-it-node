module.exports = {
    metadata: {
        family: "camera",
        plugin: "camera",
        label: "foscam Â© Camera",
        tangible: true,
        discoverable: false,
        state: [{id: "video", label: "Video", type: {id: "video"}}],
        actorTypes: [],
        sensorTypes: [],
        services: [
            {id: "panLeft", label: "Pan Left"},
            {id: "panRight", label: "Pan Right"},
            {id: "tiltUp", label: "Tilt Up"},
            {id: "tiltDown", label: "Tilt Down"},
            {id: "savePosition", label: "Save Position"},
            {id: "restorePosition", label: "Goto Position"}
        ],
        configuration: [{
            id: "host",
            label: "Host",
            type: {id: "string"}
        }, {
            id: "port",
            label: "Port",
            type: {id: "string"}
        }, {
            id: "user",
            label: "User",
            type: {id: "string"}
        }, {
            id: "password",
            label: "Password",
            type: {id: "string"}
        }, {
            id: "updateTime",
            label: "Update Time",
            type: {id: "integer"},
            default: "2000"
        }, {
            id: "hlsLiveStreaming",
            label: "HLS Live Streaming",
            type: {id: "boolean"},
            default: false
        }, {
            id: "webMLiveStreaming",
            label: "webM Live Streaming",
            type: {id: "boolean"},
            default: false
        }, {
            id: "webMPort",
            label: "webM Port",
            type: {id: "integer"},
            default: "3002"
        }]
    },
    create: function () {
        return new Camera();
    },
    discovery: function (options) {
        var discovery = new CameraDiscovery();

        discovery.options = options;

        return discovery;
    }
};

var q = require('q');
var fs = require('fs');
var https = require('https');
var child_process = require('child_process');
var foscam;
var ffmpeg;
var ffserver;
var deviceDataDirectory;
var moveDuration = 200;
var playlistName = "hls-playlist.m3u8";
var ffserverConfName = "ffserver.conf";
var httpReplaceString = "THINGITHTTPPORT";
var deviceReplaceString = "THINGITDEVICE";
var intervals;
var simulationIntervals;


function mkdirSynch(path) {
    var deferred = q.defer();

    try {
        fs.mkdirSync(path);
    } catch (e) {
        if (e.code != 'EEXIST') throw e;
    }

    deferred.resolve();
    return deferred.promise;
}

function CameraDiscovery() {
    var discoveryInterval;
    var vendors;
    var checkedIps;

    CameraDiscovery.prototype.start = function () {
        vendors = {};
        checkedIps =  {};

        if (!this.node.isSimulated()) {
            // TODO For now, need to be able to switch for Discovery or inherit from Device
            this.logLevel = "debug";
            this.scanForCameras();
            discoveryInterval = setInterval(this.scanForCameras.bind(this), 30000);
        }
    }

    CameraDiscovery.prototype.stop = function () {
        if (discoveryInterval !== undefined && discoveryInterval) {
            clearInterval(discoveryInterval);
        }
    }

    CameraDiscovery.prototype.scanForCameras = function () {
        this.scanLocalAreaNetworkHosts(function (error, ip, mac) {
            if (error) {
                this.logError(error);
            } else if (ip && !mac) {
                this.logDebug("Ignoring host with unknown MAC address.");
            } else {
                this.getVendorForMac(mac, function (err, vendor) {
                    if (err) {
                        this.logError(ip, err);
                    } else if (vendor) {
                        checkedIps[ip] = true;

                        if (-1 < vendor.indexOf("Shenzhen Reecam")) {
                            this.logInfo("Vendor match found for host "
                                + ip + ": \"" + vendor + "\"");
                            this.testCameraConnection(ip, mac);
                        }
                        else {
                            this.logDebug("Ignoring host " + ip + " with vendor " + vendor + ".");
                        }
                    } else {
                        checkedIps[ip] = true;
                        this.logDebug("No vendor found for IP " + ip + ", trying to connect anyway.");
                        this.testCameraConnection(ip, mac);
                    }
                }.bind(this));
            }
        }.bind(this));
    }

    /**
     * Searches the ARP entries for MAC addresses in the same subnet as the computer the code is running on.
     *
     * @param callback Invokes the callback for each identified MAC address. First parameter is an error,
     *                  second the ip address, third the host.
     */
    CameraDiscovery.prototype.scanLocalAreaNetworkHosts = function (callback) {
        var arp = require('node-arp');
        var network = require('network');

        network.get_active_interface(function (err, obj) {
            if (err) {
                this.logError(err);
                callback(err, false, false);
            } else {
                var myIp = obj.ip_address;
                this.logDebug("My IP address determined as " + myIp);
                var subnet = myIp.substring(0, myIp.lastIndexOf(".") + 1);
                this.logDebug("Scanning for hosts in IP range " + subnet + "1 to " + subnet + "254.");

                for (var i = 1; i < 255; i++) {
                    (function () {
                        var currentIP = subnet + i;

                        if (currentIP != myIp) {
                            if (!checkedIps[currentIP]) { // don't check the same host twice.
                                arp.getMAC(currentIP, function (err, mac) {
                                    if (err) {
                                        this.logError(currentIP, err);
                                    } else {
                                        if (mac !== undefined && mac && ("(incomplete)" != mac) && ("eth0" != mac)) {
                                            this.logDebug ("MAC address found for IP " + currentIP + ": " + mac);
                                            callback(false, currentIP, mac);
                                        } else {
                                            checkedIps[currentIP] = false;
                                        }
                                    }
                                }.bind(this));
                            }
                        }
                    }.bind(this))();
                }
            }
        }.bind(this))
    }

    /**
     * Retrieves the vendor name for a MAC address.
     * @param mac       The MAC address to look up.
     * @param callback  Invoked with return values with first parameter an error, second the vendor name.
     */
    CameraDiscovery.prototype.getVendorForMac = function (mac, callback) {
        this.logDebug("Looking up vendor for MAC address " + mac + ".");
        var cashedVendor = vendors[mac];

        if (cashedVendor || ("" == cashedVendor)) {
            this.logDebug("Retrieved vendor '" + cashedVendor + "' from vendor cache.");

            if ("" !== cashedVendor) {
                callback(false, cashedVendor);
            } else {
                callback(false, false);
            }
        } else {
            var data = "";

            var options = {
                hostname: 'www.macvendorlookup.com',
                port: 443,
                path: '/api/v2/' + mac,
                method: 'GET',
                rejectUnauthorized: false
            };

            var req = https.request(options, function (res) {
                res.on('data', function (chunk) {
                    data += chunk;
                }.bind(this));

                res.on('end', function () {
                    var vendor;

                    if ("" !== data) {
                        var vendorLookup = JSON.parse(data);

                        if ((vendorLookup !== undefined && vendorLookup) &&
                            (vendorLookup[0] !== undefined && vendorLookup[0]) &&
                            (vendorLookup[0].company !== undefined && vendorLookup[0].company)) {
                            vendor = vendorLookup[0].company;
                            this.logDebug("Vendor for MAC address " + mac + " identified as " + vendor + ".");
                            vendors[mac] = vendor;
                            callback(false, vendor);
                        }
                    } else {
                        this.logDebug("Vendor for MAC address " + mac + " not identified.");
                        vendors[mac] = "";
                        callback(false, false);
                    }
                }.bind(this));
            }.bind(this));

            req.end();

            req.on('error', function (e) {
                this.logError("MAC based vendor lookup failed for MAC address " + mac + ".", e);
                callback(e, false);
            }.bind(this));
        }

    }

    CameraDiscovery.prototype.testCameraConnection = function (host, mac) {
        this.logDebug("Testing connection to host " + host + ".");
        var discoveryFoscam = require('foscam');

        discoveryFoscam.setup({
            host: host,
            port: 80,
            user: "admin",
            pass: ""
        }, function (status) {
            if (typeof status === undefined || !status || (status.undefined && status.undefined === "undefined")) {
                this.logError("Can't connect to suspected FOSCAM camera host at " + host + " with default credentials.");

                discoveryFoscam.setup({
                    host: host,
                    port: 80,
                    user: "thingit",
                    pass: "[th1ng-1t]"
                }, function (status) {
                    if (typeof status === undefined || !status || (status.undefined && status.undefined === "undefined")) {
                        this.logError("Can't connect to FOSCAM camera at " + host + " with [thing-it] credentials." +
                            " Host skipped. ");
                    }
                    else if (status.alias !== undefined && status.alias) {
                        this.logInfo("Confirmed host " + host + " as FOSCAM camera with alias " + status.alias + ".");
                        this.advertiseCamera(status.alias, host, 80, "thingit", "[th1ng-1t]", mac);
                    }
                    else {
                        this.logError("Retrieved unexpected result from suspected FOSCAM camera at " + host +
                            ". Host skipped.");
                        this.logDebug(status);
                    }
                }.bind(this));
            }
            else if (status.alias !== undefined && status.alias) {
                this.logInfo("Confirmed host " + host + " as FOSCAM camera with alias " + status.alias + ".");
                this.advertiseCamera(status.alias, host, 80, "admin", "", mac);
            }
            else {
                this.logError("Retrieved unexpected result from suspected FOSCAM camera at " + host +
                    ". Host skipped.");
                this.logDebug(status);
            }
        }.bind(this));

    }

    CameraDiscovery.prototype.advertiseCamera = function (alias, host, port, user, pass, mac) {
        var foscamCamera = new Camera();
        foscamCamera.id = "FoscamCamera" + alias.replace(/\W/g, '');
        foscamCamera.label = alias;
        foscamCamera.uuid = mac;
        foscamCamera.configuration = {};
        foscamCamera.configuration.host = host;
        foscamCamera.configuration.port = port;
        foscamCamera.configuration.user = user;
        foscamCamera.configuration.password = pass;
        foscamCamera.configuration.hlsLiveStreaming = false;
        foscamCamera.configuration.webMLiveStreaming = false;
        this.logDebug("FOSCAM camera", foscamCamera);
        this.logInfo("Advertising camera \"" + alias + "\" with UUID " + mac + ".");
        this.advertiseDevice(foscamCamera);
    }
}

/**
 *
 */
function Camera() {
    /**
     *
     */
    Camera.prototype.start = function () {
        var deferred = q.defer();

        this.state = {};
        this.intervals = [];
        this.simulationIntervals = [];
        this.logDebug(__dirname);

        if (this.configuration.hlsLiveStreaming === undefined) {
            this.configuration.hlsLiveStreaming = false;
        }

        if (this.configuration.webMLiveStreaming === undefined) {
            this.configuration.webMLiveStreaming = false;
        }

        if (this.configuration.webMPort === undefined || !this.configuration.webMPort) {
            this.configuration.webMPort = 3002;
        }

        if (this.configuration.updateTime === undefined || !this.configuration.updateTime) {
            this.configuration.updateTime = 2000;
        }

        // Create directory for snapshot images and streaming buffer
        if (this.node.options.dataDirectory !== undefined && this.node.options.dataDirectory) {
            deviceDataDirectory = this.node.options.dataDirectory + "/devices/" + this.id;
            mkdirSynch(this.node.options.dataDirectory);
            mkdirSynch(this.node.options.dataDirectory + "/devices");
            mkdirSynch(deviceDataDirectory);

            this.imageIndex = 0;
            this.rotateIndex = 0;

            this.configuration.port = this.configuration.port || 80;
            this.configuration.user = this.configuration.user || "admin";
            this.configuration.password = this.configuration.password || "";

            if (this.isSimulated()) {
                deferred.resolve();
            } else {
                this.logDebug("Starting FOSCAM camera with configuration ", this.configuration);

                this.state.videoCGI = "http://" + this.configuration.host + ":" + this.configuration.port +
                    "/videostream.cgi?user=" + this.configuration.user + "&pwd=" + this.configuration.password;

                this.logInfo("Video CGI: " + this.state.videoCGI);

                if (!foscam) {
                    foscam = require('foscam');
                }

                foscam.setup({
                    host: this.configuration.host,
                    port: this.configuration.port,
                    user: this.configuration.user,
                    pass: this.configuration.password
                }, function (status) {
                    this.logDebug("Status :", status);

                    if (typeof status === undefined || !status || (status.undefined && status.undefined === "undefined")) {
                        this.logError("Can't connect to FOSCAM camera at " + this.configuration.host + ":"
                            + this.configuration.port + " for control.");
                        this.logError(status);
                        this.startStreaming();
                    }
                    else if (typeof status !== undefined && status) {
                        this.foscamStatus = status;
                        this.logInfo("Connected to FOSCAM camera with alias " + this.foscamStatus.alias +
                            " at IP address " + this.configuration.host + ".");
                        this.flipImage();
                        this.intervals.push(setInterval(function () {
                                this.flipImage()
                            }.bind(this),
                            this.configuration.updateTime));
                        this.startStreaming();
                    }
                    else {
                        this.logError("Retrieved unexpected result from FOSCAM API.");
                        this.logError(status);
                    }
                }.bind(this));

                deferred.resolve();
            }
        } else {
            logError("Data directory required for video streaming files not defined, cannot start FOSCAM device.");
            deferred.resolve();
        }


        return deferred.promise;
    };

    /**
     *
     *
     */
    Camera.prototype.stop = function () {
        this.logDebug("FOSCAM stop called");
        clearInterval(this.flipImageInterval);

        for (var interval in this.intervals) {
            clearInterval(interval);
        }

        for (var interval in this.simulationIntervals) {
            clearInterval(interval);
        }

        if (ffmpeg) {
            ffmpeg.kill();
        }
        if (ffserver) {
            ffserver.kill();
        }
    };

    Camera.prototype.startStreaming = function () {
        var deferred = q.defer();

        if (this.configuration.webMLiveStreaming || this.configuration.hlsLiveStreaming) {

            var ffmpegVariables = [
                "-i", "http://" + this.configuration.user + ":" + this.configuration.password + "@" +
                this.configuration.host + ":" + this.configuration.port + "/videostream.asf"
            ];

            if (this.configuration.hlsLiveStreaming) {
                this.state.playlist = "/data/devices/" + this.id + "/" + playlistName;

                fs.createReadStream(__dirname + "/data/" + playlistName).pipe(
                    fs.createWriteStream(deviceDataDirectory + "/" + playlistName));

                ffmpegVariables = ffmpegVariables.concat([
                    "-c:a", "aac", "-strict", "experimental", "-ac", "2",
                    "-b:a", "96k", "-ar", "44100", "-c:v", "libx264",
                    "-pix_fmt", "yuv420p", "-preset", "ultrafast", "-profile:v",
                    "baseline", "-level", "1.3", "-maxrate", "192k",
                    "-bufsize", "1M", "-crf", "18", "-r", "24", "-g", "72",
                    "-f", "hls", "-hls_time", "1", "-hls_list_size", "2",
                    "-hls_wrap", "4", "-s", "320x240", deviceDataDirectory + "/320x240.m3u8",
                    "-c:a", "aac", "-strict", "experimental", "-ac", "2",
                    "-b:a", "96k", "-ar", "44100", "-c:v", "libx264",
                    "-pix_fmt", "yuv420p", "-preset", "ultrafast", "-profile:v",
                    "baseline", "-level", "3.1", "-maxrate", "1M",
                    "-bufsize", "3M", "-crf", "18", "-r", "24", "-g", "72",
                    "-f", "hls", "-hls_time", "1", "-hls_list_size", "2",
                    "-hls_wrap", "4", "-s", "640x480", deviceDataDirectory + "/640x480.m3u8"
                ]);
            }

            if (this.configuration.webMLiveStreaming) {
                fs.readFile(__dirname + "/data/" + ffserverConfName, 'utf8', function (err, data) {
                    var deferred = q.defer();

                    if (err) {
                        deferred.resolve();
                        this.logError(err);
                    } else {
                        var result = data.replace(/THINGITHTTPPORT/g, this.configuration.webMPort);
                        result = result.replace(/THINGITDEVICE/g, this.id);

                        fs.writeFile(deviceDataDirectory + "/" + ffserverConfName, result, 'utf8', function (err) {
                            var deferred = q.defer();

                            if (err) {
                                deferred.resolve();
                                this.logError("Error creating FFserver configuration.", err);
                            }
                            else {
                                this.logDebug("Successfully written FFserver configuration.");

                                ffserver = child_process.spawn("ffserver", [
                                    "-f", deviceDataDirectory + "/" + ffserverConfName
                                ], {detached: false});

                                ffserver.stdout.on("data", function (data) {
                                    this.logDebug("FFserver received data.", data);
                                }.bind(this));

                                ffserver.stderr.on("data", function (data) {
                                    this.logDebug("FFserver Standard Error Out -> " + data);
                                }.bind(this));

                                ffserver.on("exit", function (code) {
                                    this.logError("FFserver terminated with code " + code);
                                }.bind(this));

                                ffserver.on("error", function (e) {
                                    this.logError("FFserver system error: " + e);
                                }.bind(this));
                                deferred.resolve();
                            }
                        }.bind(this));

                        deferred.resolve();
                    }

                    return deferred.promise;
                }.bind(this));

                var webMTarget = "http://localhost:" + this.configuration.webMPort + "/" + this.id + ".ffm";
                this.logDebug(webMTarget);
                ffmpegVariables = ffmpegVariables.concat(webMTarget);
            }

            if (ffmpeg) {
                this.logInfo("Stopping existing FFmpeg process.");
                ffmpeg.kill();
            }

            ffmpeg = child_process.spawn("ffmpeg", ffmpegVariables, {detached: false});

            ffmpeg.stdout.on("data", function (data) {
                this.logDebug("FFmpeg received data.");
                this.writeData(data);
            }.bind(this));

            ffmpeg.stderr.on("data", function (data) {
                this.logDebug("FFmpeg Standard Error Out -> " + data);
            }.bind(this));

            ffmpeg.on("exit", function (code) {
                this.logError("FFmpeg terminated with code " + code);
            }.bind(this));

            ffmpeg.on("error", function (e) {
                this.logError("FFmpeg system error: " + e);
            }.bind(this));

            deferred.resolve();
        } else {
            deferred.resolve();
            this.logDebug("Streaming not requested - skipping FFmpeg and FFserver setup.");
        }

        return deferred.promise;
    }

    /**
     *
     */
    Camera.prototype.flipImage = function () {
        this.imageIndex = (this.imageIndex + 1) % 3;
        this.rotateIndex = (this.rotateIndex + 1) % 2;

        if (!this.isSimulated()) {
            this.logDebug("Retrieving next snapshot.");
            this.snapshotLocation = deviceDataDirectory + "/snapshotImage" + this.rotateIndex + ".jpg";
            this.state.snapshotImage = "/data/devices/" + this.id + "/snapshotImage" + this.rotateIndex + ".jpg";
            foscam.snapshot(this.snapshotLocation, function (status) {
                this.logDebug("Snapshot retrieved. ", status);
                this.publishStateChange();
            }.bind(this));
        } else {
            this.logDebug("Simulation of flipImage.");
            fs.createReadStream(__dirname + "/data/snapshotImage" + this.imageIndex + ".png").pipe(
                fs.createWriteStream(deviceDataDirectory + "/snapshotImage" + this.rotateIndex + ".png"));
        }
    }

    /**
     *
     */
    Camera.prototype.setState = function (state) {
        this.state = state;
    };

    /**
     *
     */
    Camera.prototype.getState = function () {
        return this.state;
    };

    /**
     *
     */
    Camera.prototype.video = function (req, res) {
        if (this.isSimulated()) {
            this.logDebug("Piping file");
            this.pipeFile(req, res, __dirname + "/data/spaceship.m4v", "video/mp4");
        } else {
            this.logDebug("Piping playlist file for HLS.");
            this.pipeFile(req, res, deviceDataDirectory + "/hls-playlist.m3u4", "application/x-mpegURL");
        }
    };

    /**
     *
     */
    Camera.prototype.panLeft = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.pan = Math.max(-180, this.state.pan - angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position left.");

            // For unknown reasons, camera control for left and right is opposite to expectation.
            foscam.control.decoder("right", function () {
                this.logDebug("Camera moving left.");
                setTimeout(function () {
                    foscam.control.decoder("stop right", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving left.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.panRight = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.pan = Math.min(180, this.state.pan + angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position right.");

            // For unknown reasons, camera control for left and right is opposite to expectation.
            foscam.control.decoder("left", function () {
                this.logDebug("Camera moving right.");
                setTimeout(function () {
                    foscam.control.decoder("stop left", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving right.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.tiltUp = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.tilt = Math.min(180, this.state.tilt + angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position up.");
            foscam.control.decoder("up", function () {
                this.logDebug("Camera moving up.");
                setTimeout(function () {
                    foscam.control.decoder("stop up", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving up.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.tiltDown = function (parameters) {
        var angle = parameters && parameters.angle ? parameters.angle : 5;

        if (this.isSimulated()) {
            this.state.tilt = Math.max(-180, this.state.tilt - angle);

            this.flipImage();
            this.publishStateChange();
        } else {
            this.logDebug("Moving camera position down.");
            foscam.control.decoder("down", function () {
                this.logDebug("Camera moving down.");
                setTimeout(function () {
                    foscam.control.decoder("stop down", function (data) {
                        this.logError(data);
                        this.logDebug("Camera stopped moving down.");
                        this.publishStateChange();
                    }.bind(this))
                }.bind(this), moveDuration);
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.savePosition = function (parameters) {
        if (this.isSimulated()) {
            this.flipImage();
        } else {
            this.logDebug("Saving position.");
            foscam.preset.set(16, function (status) {
                if (status !== undefined && status) {
                    if (status == "ok.") {
                        this.logDebug("Position saved.");
                    }
                    else {
                        this.logDebug("Position not saved: ", status);
                    }
                }
            }.bind(this));
        }
    };

    /**
     *
     */
    Camera.prototype.restorePosition = function (parameters) {
        if (this.isSimulated()) {
            this.flipImage();
        } else {
            this.logDebug("Restoring position.");
            foscam.preset.go(16, function (status) {
                if (status !== undefined && status) {
                    if (status == "ok.") {
                        this.logDebug("Restored position.");
                    }
                    else {
                        this.logError("Error restoring position: ", status);
                    }
                }
            }.bind(this));
        }
    };
}
